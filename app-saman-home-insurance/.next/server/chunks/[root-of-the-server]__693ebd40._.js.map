{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 3, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 43, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/matta/Desktop/Projects/saman-home-insurance/src/swagger/core/OpenAPI.ts"],"sourcesContent":["/* generated using openapi-typescript-codegen -- do not edit */\n/* istanbul ignore file */\n/* tslint:disable */\n/* eslint-disable */\nimport type { ApiRequestOptions } from './ApiRequestOptions';\n\ntype Resolver<T> = (options: ApiRequestOptions) => Promise<T>;\ntype Headers = Record<string, string>;\n\nexport type OpenAPIConfig = {\n    BASE: string;\n    VERSION: string;\n    WITH_CREDENTIALS: boolean;\n    CREDENTIALS: 'include' | 'omit' | 'same-origin';\n    TOKEN?: string | Resolver<string> | undefined;\n    USERNAME?: string | Resolver<string> | undefined;\n    PASSWORD?: string | Resolver<string> | undefined;\n    HEADERS?: Headers | Resolver<Headers> | undefined;\n    ENCODE_PATH?: ((path: string) => string) | undefined;\n};\n\nexport const OpenAPI: OpenAPIConfig = {\n    BASE: process.env.NEXT_PUBLIC_API_URL || 'http://localhost:5000',\n    VERSION: '1',\n    WITH_CREDENTIALS: false,\n    CREDENTIALS: 'include',\n    TOKEN: undefined,\n    USERNAME: undefined,\n    PASSWORD: undefined,\n    HEADERS: undefined,\n    ENCODE_PATH: undefined,\n};\n"],"names":[],"mappings":"AAAA,6DAA6D,GAC7D,wBAAwB,GACxB,kBAAkB,GAClB,kBAAkB;;;;AAkBX,MAAM,UAAyB;IAClC,MAAM,QAAQ,GAAG,CAAC,mBAAmB,IAAI;IACzC,SAAS;IACT,kBAAkB;IAClB,aAAa;IACb,OAAO;IACP,UAAU;IACV,UAAU;IACV,SAAS;IACT,aAAa;AACjB","debugId":null}},
    {"offset": {"line": 62, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/matta/Desktop/Projects/saman-home-insurance/src/swagger/core/ApiError.ts"],"sourcesContent":["/* generated using openapi-typescript-codegen -- do not edit */\n/* istanbul ignore file */\n/* tslint:disable */\n/* eslint-disable */\nimport type { ApiRequestOptions } from './ApiRequestOptions';\nimport type { ApiResult } from './ApiResult';\n\nexport class ApiError extends Error {\n    public readonly url: string;\n    public readonly status: number;\n    public readonly statusText: string;\n    public readonly body: any;\n    public readonly request: ApiRequestOptions;\n\n    constructor(request: ApiRequestOptions, response: ApiResult, message: string) {\n        super(message);\n\n        this.name = 'ApiError';\n        this.url = response.url;\n        this.status = response.status;\n        this.statusText = response.statusText;\n        this.body = response.body;\n        this.request = request;\n    }\n}\r\n"],"names":[],"mappings":"AAAA,6DAA6D,GAC7D,wBAAwB,GACxB,kBAAkB,GAClB,kBAAkB;;;;AAIX,MAAM,iBAAiB;IACV,IAAY;IACZ,OAAe;IACf,WAAmB;IACnB,KAAU;IACV,QAA2B;IAE3C,YAAY,OAA0B,EAAE,QAAmB,EAAE,OAAe,CAAE;QAC1E,KAAK,CAAC;QAEN,IAAI,CAAC,IAAI,GAAG;QACZ,IAAI,CAAC,GAAG,GAAG,SAAS,GAAG;QACvB,IAAI,CAAC,MAAM,GAAG,SAAS,MAAM;QAC7B,IAAI,CAAC,UAAU,GAAG,SAAS,UAAU;QACrC,IAAI,CAAC,IAAI,GAAG,SAAS,IAAI;QACzB,IAAI,CAAC,OAAO,GAAG;IACnB;AACJ","debugId":null}},
    {"offset": {"line": 86, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/matta/Desktop/Projects/saman-home-insurance/src/swagger/core/CancelablePromise.ts"],"sourcesContent":["// @ts-nocheck\n/* generated using openapi-typescript-codegen -- do not edit */\n/* istanbul ignore file */\n/* tslint:disable */\n/* eslint-disable */\nexport class CancelError extends Error {\n\n    constructor(message: string) {\n        super(message);\n        this.name = 'CancelError';\n    }\n\n    public get isCancelled(): boolean {\n        return true;\n    }\n}\n\nexport interface OnCancel {\n    readonly isResolved: boolean;\n    readonly isRejected: boolean;\n    readonly isCancelled: boolean;\n\n    (cancelHandler: () => void): void;\n}\n\nexport class CancelablePromise<T> implements Promise<T> {\n    #isResolved: boolean;\n    #isRejected: boolean;\n    #isCancelled: boolean;\n    readonly #cancelHandlers: (() => void)[];\n    readonly #promise: Promise<T>;\n    #resolve?: (value: T | PromiseLike<T>) => void;\n    #reject?: (reason?: any) => void;\n\n    constructor(\n        executor: (\n            resolve: (value: T | PromiseLike<T>) => void,\n            reject: (reason?: any) => void,\n            onCancel: OnCancel\n        ) => void\n    ) {\n        this.#isResolved = false;\n        this.#isRejected = false;\n        this.#isCancelled = false;\n        this.#cancelHandlers = [];\n        this.#promise = new Promise<T>((resolve, reject) => {\n            this.#resolve = resolve;\n            this.#reject = reject;\n\n            const onResolve = (value: T | PromiseLike<T>): void => {\n                if (this.#isResolved || this.#isRejected || this.#isCancelled) {\n                    return;\n                }\n                this.#isResolved = true;\n                if (this.#resolve) this.#resolve(value);\n            };\n\n            const onReject = (reason?: any): void => {\n                if (this.#isResolved || this.#isRejected || this.#isCancelled) {\n                    return;\n                }\n                this.#isRejected = true;\n                if (this.#reject) this.#reject(reason);\n            };\n\n            const onCancel = (cancelHandler: () => void): void => {\n                if (this.#isResolved || this.#isRejected || this.#isCancelled) {\n                    return;\n                }\n                this.#cancelHandlers.push(cancelHandler);\n            };\n\n            Object.defineProperty(onCancel, 'isResolved', {\n                get: (): boolean => this.#isResolved,\n            });\n\n            Object.defineProperty(onCancel, 'isRejected', {\n                get: (): boolean => this.#isRejected,\n            });\n\n            Object.defineProperty(onCancel, 'isCancelled', {\n                get: (): boolean => this.#isCancelled,\n            });\n\n            return executor(onResolve, onReject, onCancel as OnCancel);\n        });\n    }\n\n    get [Symbol.toStringTag]() {\n        return \"Cancellable Promise\";\n    }\n\n    public then<TResult1 = T, TResult2 = never>(\n        onFulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | null,\n        onRejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null\n    ): Promise<TResult1 | TResult2> {\n        return this.#promise.then(onFulfilled, onRejected);\n    }\n\n    public catch<TResult = never>(\n        onRejected?: ((reason: any) => TResult | PromiseLike<TResult>) | null\n    ): Promise<T | TResult> {\n        return this.#promise.catch(onRejected);\n    }\n\n    public finally(onFinally?: (() => void) | null): Promise<T> {\n        return this.#promise.finally(onFinally);\n    }\n\n    public cancel(): void {\n        if (this.#isResolved || this.#isRejected || this.#isCancelled) {\n            return;\n        }\n        this.#isCancelled = true;\n        if (this.#cancelHandlers.length) {\n            try {\n                for (const cancelHandler of this.#cancelHandlers) {\n                    cancelHandler();\n                }\n            } catch (error) {\n                console.warn('Cancellation threw an error', error);\n                return;\n            }\n        }\n        this.#cancelHandlers.length = 0;\n        if (this.#reject) this.#reject(new CancelError('Request aborted'));\n    }\n\n    public get isCancelled(): boolean {\n        return this.#isCancelled;\n    }\n}\r\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 188, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/matta/Desktop/Projects/saman-home-insurance/src/swagger/core/request.ts"],"sourcesContent":["/* generated using openapi-typescript-codegen -- do not edit */\n/* istanbul ignore file */\n/* tslint:disable */\n/* eslint-disable */\nimport { ApiError } from './ApiError';\nimport type { ApiRequestOptions } from './ApiRequestOptions';\nimport type { ApiResult } from './ApiResult';\nimport { CancelablePromise } from './CancelablePromise';\nimport type { OnCancel } from './CancelablePromise';\nimport type { OpenAPIConfig } from './OpenAPI';\n\nexport const isDefined = <T>(value: T | null | undefined): value is Exclude<T, null | undefined> => {\n    return value !== undefined && value !== null;\n};\n\nexport const isString = (value: any): value is string => {\n    return typeof value === 'string';\n};\n\nexport const isStringWithValue = (value: any): value is string => {\n    return isString(value) && value !== '';\n};\n\nexport const isBlob = (value: any): value is Blob => {\n    return (\n        typeof value === 'object' &&\n        typeof value.type === 'string' &&\n        typeof value.stream === 'function' &&\n        typeof value.arrayBuffer === 'function' &&\n        typeof value.constructor === 'function' &&\n        typeof value.constructor.name === 'string' &&\n        /^(Blob|File)$/.test(value.constructor.name) &&\n        /^(Blob|File)$/.test(value[Symbol.toStringTag])\n    );\n};\n\nexport const isFormData = (value: any): value is FormData => {\n    return value instanceof FormData;\n};\n\nexport const base64 = (str: string): string => {\n    try {\n        return btoa(str);\n    } catch (err) {\n        // @ts-ignore\n        return Buffer.from(str).toString('base64');\n    }\n};\n\nexport const getQueryString = (params: Record<string, any>): string => {\n    const qs: string[] = [];\n\n    const append = (key: string, value: any) => {\n        qs.push(`${encodeURIComponent(key)}=${encodeURIComponent(String(value))}`);\n    };\n\n    const process = (key: string, value: any) => {\n        if (isDefined(value)) {\n            if (Array.isArray(value)) {\n                value.forEach(v => {\n                    process(key, v);\n                });\n            } else if (typeof value === 'object') {\n                Object.entries(value).forEach(([k, v]) => {\n                    process(`${key}[${k}]`, v);\n                });\n            } else {\n                append(key, value);\n            }\n        }\n    };\n\n    Object.entries(params).forEach(([key, value]) => {\n        process(key, value);\n    });\n\n    if (qs.length > 0) {\n        return `?${qs.join('&')}`;\n    }\n\n    return '';\n};\n\nconst getUrl = (config: OpenAPIConfig, options: ApiRequestOptions): string => {\n    const encoder = config.ENCODE_PATH || encodeURI;\n\n    const path = options.url\n        .replace('{api-version}', config.VERSION)\n        .replace(/{(.*?)}/g, (substring: string, group: string) => {\n            if (options.path?.hasOwnProperty(group)) {\n                return encoder(String(options.path[group]));\n            }\n            return substring;\n        });\n\n    const url = `${config.BASE}${path}`;\n    if (options.query) {\n        return `${url}${getQueryString(options.query)}`;\n    }\n    return url;\n};\n\nexport const getFormData = (options: ApiRequestOptions): FormData | undefined => {\n    if (options.formData) {\n        const formData = new FormData();\n\n        const process = (key: string, value: any) => {\n            if (isString(value) || isBlob(value)) {\n                formData.append(key, value);\n            } else {\n                formData.append(key, JSON.stringify(value));\n            }\n        };\n\n        Object.entries(options.formData)\n            .filter(([_, value]) => isDefined(value))\n            .forEach(([key, value]) => {\n                if (Array.isArray(value)) {\n                    value.forEach(v => process(key, v));\n                } else {\n                    process(key, value);\n                }\n            });\n\n        return formData;\n    }\n    return undefined;\n};\n\ntype Resolver<T> = (options: ApiRequestOptions) => Promise<T>;\n\nexport const resolve = async <T>(options: ApiRequestOptions, resolver?: T | Resolver<T>): Promise<T | undefined> => {\n    if (typeof resolver === 'function') {\n        return (resolver as Resolver<T>)(options);\n    }\n    return resolver;\n};\n\nexport const getHeaders = async (config: OpenAPIConfig, options: ApiRequestOptions): Promise<Headers> => {\n    const [token, username, password, additionalHeaders] = await Promise.all([\n        resolve(options, config.TOKEN),\n        resolve(options, config.USERNAME),\n        resolve(options, config.PASSWORD),\n        resolve(options, config.HEADERS),\n    ]);\n\n    const headers = Object.entries({\n        Accept: 'application/json',\n        ...additionalHeaders,\n        ...options.headers,\n    })\n        .filter(([_, value]) => isDefined(value))\n        .reduce((headers, [key, value]) => ({\n            ...headers,\n            [key]: String(value),\n        }), {} as Record<string, string>);\n\n    if (isStringWithValue(token)) {\n        headers['Authorization'] = `Bearer ${token}`;\n    }\n\n    if (isStringWithValue(username) && isStringWithValue(password)) {\n        const credentials = base64(`${username}:${password}`);\n        headers['Authorization'] = `Basic ${credentials}`;\n    }\n\n    if (options.body !== undefined) {\n        if (options.mediaType) {\n            headers['Content-Type'] = options.mediaType;\n        } else if (isBlob(options.body)) {\n            headers['Content-Type'] = options.body.type || 'application/octet-stream';\n        } else if (isString(options.body)) {\n            headers['Content-Type'] = 'text/plain';\n        } else if (!isFormData(options.body)) {\n            headers['Content-Type'] = 'application/json';\n        }\n    }\n\n    return new Headers(headers);\n};\n\nexport const getRequestBody = (options: ApiRequestOptions): any => {\n    if (options.body !== undefined) {\n        if (options.mediaType?.includes('/json')) {\n            return JSON.stringify(options.body)\n        } else if (isString(options.body) || isBlob(options.body) || isFormData(options.body)) {\n            return options.body;\n        } else {\n            return JSON.stringify(options.body);\n        }\n    }\n    return undefined;\n};\n\nexport const sendRequest = async (\n    config: OpenAPIConfig,\n    options: ApiRequestOptions,\n    url: string,\n    body: any,\n    formData: FormData | undefined,\n    headers: Headers,\n    onCancel: OnCancel\n): Promise<Response> => {\n    const controller = new AbortController();\n\n    const request: RequestInit = {\n        headers,\n        body: body ?? formData,\n        method: options.method,\n        signal: controller.signal,\n    };\n\n    if (config.WITH_CREDENTIALS) {\n        request.credentials = config.CREDENTIALS;\n    }\n\n    onCancel(() => controller.abort());\n\n    return await fetch(url, request);\n};\n\nexport const getResponseHeader = (response: Response, responseHeader?: string): string | undefined => {\n    if (responseHeader) {\n        const content = response.headers.get(responseHeader);\n        if (isString(content)) {\n            return content;\n        }\n    }\n    return undefined;\n};\n\nexport const getResponseBody = async (response: Response): Promise<any> => {\n    if (response.status !== 204) {\n        try {\n            const contentType = response.headers.get('Content-Type');\n            if (contentType) {\n                const jsonTypes = ['application/json', 'application/problem+json']\n                const isJSON = jsonTypes.some(type => contentType.toLowerCase().startsWith(type));\n                if (isJSON) {\n                    return await response.json();\n                } else {\n                    return await response.text();\n                }\n            }\n        } catch (error) {\n            console.error(error);\n        }\n    }\n    return undefined;\n};\n\nexport const catchErrorCodes = (options: ApiRequestOptions, result: ApiResult): void => {\n    const errors: Record<number, string> = {\n        400: 'Bad Request',\n        401: 'Unauthorized',\n        403: 'Forbidden',\n        404: 'Not Found',\n        500: 'Internal Server Error',\n        502: 'Bad Gateway',\n        503: 'Service Unavailable',\n        ...options.errors,\n    }\n\n    const error = errors[result.status];\n    if (error) {\n        throw new ApiError(options, result, error);\n    }\n\n    if (!result.ok) {\n        const errorStatus = result.status ?? 'unknown';\n        const errorStatusText = result.statusText ?? 'unknown';\n        const errorBody = (() => {\n            try {\n                return JSON.stringify(result.body, null, 2);\n            } catch (e) {\n                return undefined;\n            }\n        })();\n\n        throw new ApiError(options, result,\n            `Generic Error: status: ${errorStatus}; status text: ${errorStatusText}; body: ${errorBody}`\n        );\n    }\n};\n\n/**\n * Request method\n * @param config The OpenAPI configuration object\n * @param options The request options from the service\n * @returns CancelablePromise<T>\n * @throws ApiError\n */\nexport const request = <T>(config: OpenAPIConfig, options: ApiRequestOptions): CancelablePromise<T> => {\n    return new CancelablePromise(async (resolve, reject, onCancel) => {\n        try {\n            const url = getUrl(config, options);\n            const formData = getFormData(options);\n            const body = getRequestBody(options);\n            const headers = await getHeaders(config, options);\n\n            if (!onCancel.isCancelled) {\n                const response = await sendRequest(config, options, url, body, formData, headers, onCancel);\n                const responseBody = await getResponseBody(response);\n                const responseHeader = getResponseHeader(response, options.responseHeader);\n\n                const result: ApiResult = {\n                    url,\n                    ok: response.ok,\n                    status: response.status,\n                    statusText: response.statusText,\n                    body: responseHeader ?? responseBody,\n                };  \n\n                catchErrorCodes(options, result);\n\n                resolve(result.body);\n            }\n        } catch (error) {\n            reject(error);\n        }\n    });\n};\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 468, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/matta/Desktop/Projects/saman-home-insurance/src/swagger/services/UserAuthenticationOtpService.ts"],"sourcesContent":["/* generated using openapi-typescript-codegen -- do not edit */\r\n/* istanbul ignore file */\r\n/* tslint:disable */\r\n/* eslint-disable */\r\nimport type { OtpDto } from '../models/OtpDto';\r\nimport type { OtpRequestDto } from '../models/OtpRequestDto';\r\nimport type { CancelablePromise } from '../core/CancelablePromise';\r\nimport { OpenAPI } from '../core/OpenAPI';\r\nimport { request as __request } from '../core/request';\r\nexport class UserAuthenticationOtpService {\r\n    /**\r\n     * @returns any OK\r\n     * @throws ApiError\r\n     */\r\n    public static postApiV1UsersRequestOtp({\r\n        requestBody,\r\n    }: {\r\n        requestBody: OtpRequestDto,\r\n    }): CancelablePromise<any> {\r\n        return __request(OpenAPI, {\r\n            method: 'POST',\r\n            url: '/api/v1/Users/RequestOtp',\r\n            body: requestBody,\r\n            mediaType: 'application/json',\r\n        });\r\n    }\r\n    /**\r\n     * @returns any OK\r\n     * @throws ApiError\r\n     */\r\n    public static postApiV1UsersVerifyOtp({\r\n        requestBody,\r\n    }: {\r\n        requestBody: OtpDto,\r\n    }): CancelablePromise<any> {\r\n        return __request(OpenAPI, {\r\n            method: 'POST',\r\n            url: '/api/v1/Users/VerifyOtp',\r\n            body: requestBody,\r\n            mediaType: 'application/json',\r\n        });\r\n    }\r\n}\r\n"],"names":[],"mappings":"AAAA,6DAA6D,GAC7D,wBAAwB,GACxB,kBAAkB,GAClB,kBAAkB;;;;AAIlB;AACA;;;AACO,MAAM;IACT;;;KAGC,GACD,OAAc,yBAAyB,EACnC,WAAW,EAGd,EAA0B;QACvB,OAAO,IAAA,8IAAS,EAAC,8IAAO,EAAE;YACtB,QAAQ;YACR,KAAK;YACL,MAAM;YACN,WAAW;QACf;IACJ;IACA;;;KAGC,GACD,OAAc,wBAAwB,EAClC,WAAW,EAGd,EAA0B;QACvB,OAAO,IAAA,8IAAS,EAAC,8IAAO,EAAE;YACtB,QAAQ;YACR,KAAK;YACL,MAAM;YACN,WAAW;QACf;IACJ;AACJ","debugId":null}},
    {"offset": {"line": 504, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/matta/Desktop/Projects/saman-home-insurance/src/lib/api-error-handler.ts"],"sourcesContent":["/**\r\n * Comprehensive API error handler utility\r\n * Handles various error structures including arrays, Ardalis Result patterns, and different API response formats\r\n */\r\n\r\n// Helper function to safely get error message from various structures\r\nconst extractErrorMessage = (obj: any): string | null => {\r\n  if (!obj) return null;\r\n  \r\n  // Check if obj is an array, process each item\r\n  if (Array.isArray(obj)) {\r\n    const errorMessages: string[] = [];\r\n    \r\n    for (const item of obj) {\r\n      if (item && typeof item === 'object') {\r\n        // Check for errorMessage property (our target)\r\n        if (typeof item.errorMessage === 'string' && item.errorMessage.trim()) {\r\n          errorMessages.push(item.errorMessage);\r\n        }\r\n        // Check for other properties if errorMessage is not found\r\n        else if (typeof item.detail === 'string' && item.detail.trim()) {\r\n          errorMessages.push(item.detail);\r\n        }\r\n        else if (typeof item.message === 'string' && item.message.trim()) {\r\n          errorMessages.push(item.message);\r\n        }\r\n      }\r\n    }\r\n    \r\n    if (errorMessages.length > 0) {\r\n      return errorMessages.join('\\n');\r\n    }\r\n  }\r\n  \r\n  // Normalize common casing differences (FastEndpoints often uses capital keys)\r\n  const errorsKey = (obj.errors ?? obj.Errors) as any;\r\n  const messageKey = obj.message ?? obj.Message;\r\n  const detailKey = obj.detail ?? obj.Detail;\r\n  const titleKey = obj.title ?? obj.Title;\r\n  const statusKey = obj.status ?? obj.Status ?? obj.statusCode ?? obj.StatusCode;\r\n\r\n  // Check for Ardalis/FastEndpoints Result pattern - errors array (objects or strings)\r\n  if (errorsKey && Array.isArray(errorsKey)) {\r\n    const errorMessages: string[] = [];\r\n    \r\n    for (const error of errorsKey) {\r\n      if (error && typeof error === 'object') {\r\n        // Check for errorMessage property (our target)\r\n        if (typeof error.errorMessage === 'string' && error.errorMessage.trim()) {\r\n          errorMessages.push(error.errorMessage);\r\n        }\r\n        // Check for other properties if errorMessage is not found\r\n        else if (typeof error.detail === 'string' && error.detail.trim()) {\r\n          errorMessages.push(error.detail);\r\n        }\r\n        else if (typeof error.message === 'string' && error.message.trim()) {\r\n          errorMessages.push(error.message);\r\n        }\r\n        // Check for value property (common in Ardalis Result)\r\n        else if (typeof error.value === 'string' && error.value.trim()) {\r\n          errorMessages.push(error.value);\r\n        }\r\n        // Check for code/description tuple (common in FastEndpoints validation)\r\n        else if (typeof (error.description ?? error.Description) === 'string') {\r\n          errorMessages.push(String(error.description ?? error.Description));\r\n        }\r\n      } else if (typeof error === 'string' && error.trim()) {\r\n        // Ardalis sometimes returns array of strings\r\n        errorMessages.push(error);\r\n      }\r\n    }\r\n    \r\n    if (errorMessages.length > 0) {\r\n      return errorMessages.join('\\n');\r\n    }\r\n  }\r\n  \r\n  // Check for Ardalis Result pattern - isSuccess = false with single error\r\n  if (obj.isSuccess === false) {\r\n    // Check for single error object\r\n    if (obj.error && typeof obj.error === 'object') {\r\n      const errorMsg = extractErrorMessage(obj.error);\r\n      if (errorMsg) return errorMsg;\r\n    }\r\n    \r\n    // Check for error message directly\r\n    if (typeof obj.errorMessage === 'string' && obj.errorMessage.trim()) {\r\n      return obj.errorMessage;\r\n    }\r\n    \r\n    // Check for value property (common in failed Ardalis Results)\r\n    if (typeof obj.value === 'string' && obj.value.trim()) {\r\n      return obj.value;\r\n    }\r\n  }\r\n  \r\n  // Check for errorMessage property (our target)\r\n  if (typeof obj.errorMessage === 'string' && obj.errorMessage.trim()) {\r\n    return obj.errorMessage;\r\n  }\r\n  \r\n  // Check for validation errors object (lower/upper-case keys)\r\n  if (errorsKey && typeof errorsKey === 'object' && !Array.isArray(errorsKey)) {\r\n    const validationErrors = Object.values(errorsKey).flat().join(\"\\n\");\r\n    if (validationErrors.trim()) {\r\n      return `خطاهای اعتبارسنجی:\\n${validationErrors}`;\r\n    }\r\n  }\r\n  \r\n  // ProblemDetails style\r\n  if (typeof detailKey === 'string' && detailKey.trim()) {\r\n    return detailKey;\r\n  }\r\n  \r\n  // Message style\r\n  if (typeof messageKey === 'string' && messageKey.trim()) {\r\n    return messageKey;\r\n  }\r\n\r\n  // Combine title + status\r\n  if (titleKey && statusKey) {\r\n    return `${titleKey} (${statusKey})`;\r\n  }\r\n  \r\n  return null;\r\n};\r\n\r\n/**\r\n * Main API error handler function\r\n * @param error - The error object from API calls\r\n * @param defaultMessage - Default message to show if no specific error is found\r\n * @returns Formatted error message string with preserved status codes\r\n */\r\nexport const handleApiError = (error: any, defaultMessage: string = \"خطایی رخ داد. لطفا دوباره تلاش کنید.\"): string => {\r\n  console.log(\"Handling API error:\", error);\r\n  \r\n  // Preserve specific error codes like 429 (Too Many Requests)\r\n  if (error?.status === 429) {\r\n    return \"درخواست‌های زیادی ارسال شده است. لطفا کمی صبر کنید و دوباره تلاش کنید.\";\r\n  }\r\n  \r\n  // 1. Check ApiError body (swagger-generated errors)\r\n  if (error?.body) {\r\n    const message = extractErrorMessage(error.body);\r\n    if (message) {\r\n      console.log(\"Found error in error.body:\", message);\r\n      return message;\r\n    }\r\n  }\r\n  \r\n  // 2. Check if error itself has the properties\r\n  const directMessage = extractErrorMessage(error);\r\n  if (directMessage) {\r\n    console.log(\"Found error in error object:\", directMessage);\r\n    return directMessage;\r\n  }\r\n  \r\n  // 3. Check response.body structure\r\n  if (error?.response?.body) {\r\n    const message = extractErrorMessage(error.response.body);\r\n    if (message) {\r\n      console.log(\"Found error in error.response.body:\", message);\r\n      return message;\r\n    }\r\n  }\r\n  \r\n  // 4. Check if body is a string and try to parse it\r\n  if (typeof error?.body === 'string') {\r\n    try {\r\n      const parsed = JSON.parse(error.body);\r\n      const message = extractErrorMessage(parsed);\r\n      if (message) {\r\n        console.log(\"Found error in parsed body:\", message);\r\n        return message;\r\n      }\r\n    } catch (e) {\r\n      console.log(\"Failed to parse error body as JSON\");\r\n    }\r\n  }\r\n  \r\n  // 5. Check if response.body is a string and try to parse it\r\n  if (typeof error?.response?.body === 'string') {\r\n    try {\r\n      const parsed = JSON.parse(error.response.body);\r\n      const message = extractErrorMessage(parsed);\r\n      if (message) {\r\n        console.log(\"Found error in parsed response.body:\", message);\r\n        return message;\r\n      }\r\n    } catch (e) {\r\n      console.log(\"Failed to parse response.body as JSON\");\r\n    }\r\n  }\r\n  \r\n  // 6. Fallback to error.message if it's not generic\r\n  if (error?.message && \r\n      error.message !== 'Bad Request' && \r\n      error.message !== 'Network Error' &&\r\n      error.message !== 'Unauthorized' &&\r\n      error.message !== 'Forbidden' &&\r\n      error.message.trim()) {\r\n    console.log(\"Using error.message as fallback:\", error.message);\r\n    return error.message;\r\n  }\r\n  \r\n  // 7. Last resort - return default message\r\n  console.log(\"No meaningful error message found, using default\");\r\n  return defaultMessage;\r\n};\r\n\r\n/**\r\n * Clean error message by removing common prefixes\r\n * @param errorMessage - Raw error message\r\n * @returns Cleaned error message\r\n */\r\nexport const cleanErrorMessage = (errorMessage: string): string => {\r\n  return errorMessage\r\n    .replace(\"Next error(s) occurred:*\", \"\")\r\n    .replace(\"Next error(s) occurred:\", \"\")\r\n    .trim();\r\n};\r\n\r\n/**\r\n * Handle API error with automatic cleaning\r\n * @param error - The error object from API calls\r\n * @param defaultMessage - Default message to show if no specific error is found\r\n * @returns Cleaned and formatted error message string\r\n */\r\nexport const handleApiErrorWithCleanup = (error: any, defaultMessage: string = \"خطایی رخ داد. لطفا دوباره تلاش کنید.\"): string => {\r\n  const message = handleApiError(error, defaultMessage);\r\n  return cleanErrorMessage(message);\r\n};\r\n\r\n/**\r\n * Handle API error and return detailed error information including status codes\r\n * @param error - The error object from API calls\r\n * @param defaultMessage - Default message to show if no specific error is found\r\n * @returns Object containing message, status code, and other error details\r\n */\r\nexport const handleApiErrorWithDetails = (error: any, defaultMessage: string = \"خطایی رخ داد. لطفا دوباره تلاش کنید.\") => {\r\n  const message = handleApiErrorWithCleanup(error, defaultMessage);\r\n  \r\n  return {\r\n    message,\r\n    status: error?.status || error?.response?.status || null,\r\n    code: error?.code || error?.response?.code || null,\r\n    type: error?.body?.type || error?.response?.body?.type || null,\r\n    title: error?.body?.title || error?.response?.body?.title || null,\r\n    detail: error?.body?.detail || error?.response?.body?.detail || null,\r\n    body: error?.body || error?.response?.body || null,\r\n  };\r\n};\r\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 698, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/matta/Desktop/Projects/saman-home-insurance/src/lib/openapi-config.ts"],"sourcesContent":["/**\r\n * OpenAPI configuration initializer\r\n * This module should be imported early to ensure the correct base URL is set\r\n * before any API calls are made.\r\n */\r\n\r\nimport { OpenAPI } from '@/swagger/core/OpenAPI';\r\n\r\n// Initialize OpenAPI configuration with environment variables\r\nfunction initializeOpenAPI() {\r\n  // Set base URL from environment variable, fallback to current base if not set\r\n  const baseUrl = process.env.NEXT_PUBLIC_API_URL;\r\n  \r\n  if (baseUrl) {\r\n    OpenAPI.BASE = baseUrl;\r\n    console.log('🔧 [OpenAPI] Base URL set to:', baseUrl);\r\n  } else {\r\n    console.warn('⚠️ [OpenAPI] NEXT_PUBLIC_API_URL not found, using default:', OpenAPI.BASE);\r\n  }\r\n}\r\n\r\n// Initialize immediately when this module is imported\r\ninitializeOpenAPI();\r\n\r\nexport { initializeOpenAPI };"],"names":[],"mappings":"AAAA;;;;CAIC;;;;AAED;;AAEA,8DAA8D;AAC9D,SAAS;IACP,8EAA8E;IAC9E,MAAM,UAAU,QAAQ,GAAG,CAAC,mBAAmB;IAE/C,IAAI,SAAS;QACX,8IAAO,CAAC,IAAI,GAAG;QACf,QAAQ,GAAG,CAAC,iCAAiC;IAC/C,OAAO;QACL,QAAQ,IAAI,CAAC,8DAA8D,8IAAO,CAAC,IAAI;IACzF;AACF;AAEA,sDAAsD;AACtD","debugId":null}},
    {"offset": {"line": 726, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/matta/Desktop/Projects/saman-home-insurance/src/lib/auth.ts"],"sourcesContent":["import { AuthOptions } from \"next-auth\";\r\nimport CredentialsProvider from \"next-auth/providers/credentials\";\r\nimport { UserAuthenticationOtpService } from \"@/swagger/services/UserAuthenticationOtpService\"\r\nimport { handleApiErrorWithCleanup } from \"@/lib/api-error-handler\";\r\nimport { OpenAPI } from \"@/swagger/core/OpenAPI\";\r\n// Initialize OpenAPI configuration early\r\nimport \"@/lib/openapi-config\";\r\nimport { OtpDto } from \"@/swagger/models/OtpDto\";\r\n\r\nexport const authOptions: AuthOptions = {\r\n  providers: [\r\n    CredentialsProvider({\r\n      id: \"otp-login\",\r\n      name: \"OTP Login\",\r\n      credentials: {\r\n        phoneNumber: { label: \"Phone Number\", type: \"text\" },\r\n        otp: { label: \"Otp\", type: \"text\" },\r\n        // recaptchaToken: { label: \"ReCAPTCHA Token\", type: \"text\" },\r\n      },\r\n      async authorize(credentials) {\r\n        if (!credentials?.phoneNumber || !credentials?.otp) {\r\n          throw new Error(\"شماره تلفن و کد تایید الزامی است\");\r\n        }\r\n\r\n        try {\r\n          const requestBody = {\r\n            phoneNumber: credentials.phoneNumber,\r\n            otp: credentials.otp,\r\n          } as OtpDto;\r\n\r\n          // Add captcha token if provided\r\n          // if (credentials.recaptchaToken) {\r\n          //   requestBody.captchaToken = credentials.recaptchaToken;\r\n          // }\r\n          const check = OpenAPI;\r\n          const response = await UserAuthenticationOtpService.postApiV1UsersVerifyOtp({\r\n            requestBody,\r\n          });\r\n\r\n          console.log(\"OTP login response:\", response);\r\n\r\n          if (response?.accessToken && response?.refreshToken) {\r\n            // Extract user ID from JWT token's sub claim, or use phone number as fallback\r\n            let userId: string;\r\n            try {\r\n              const tokenPayload = JSON.parse(atob(response.accessToken.split('.')[1]));\r\n              userId = tokenPayload.sub || credentials.phoneNumber;\r\n            } catch {\r\n              userId = credentials.phoneNumber;\r\n            }\r\n\r\n            return {\r\n              id: userId,\r\n              phoneNumber: credentials.phoneNumber,\r\n              accessToken: response.accessToken,\r\n              refreshToken: response.refreshToken,\r\n            } as const;\r\n          }\r\n          throw new Error(\"پاسخ نامعتبر از سرور\");\r\n        } catch (error) {\r\n          console.error(\"OTP login error:\", error);\r\n          const errorMessage = handleApiErrorWithCleanup(error, \"کد تایید نامعتبر است. لطفا دوباره تلاش کنید.\");\r\n          throw new Error(errorMessage);\r\n        }\r\n      },\r\n    }),\r\n  ],\r\n  callbacks: {\r\n    async jwt({ token, user }) {\r\n      // The user object passed here contains the data returned by the authorize function\r\n      if (user) {\r\n        token.accessToken = user.accessToken;\r\n        token.refreshToken = user.refreshToken;\r\n        token.sub = user.id; // Store user ID in token\r\n        token.id = user.id;\r\n      }\r\n      return token;\r\n    },\r\n    async session({ session, token }) {\r\n      // The token object contains the data from the jwt callback\r\n      if (token) {\r\n        session.accessToken = token.accessToken;\r\n        session.refreshToken = token.refreshToken;\r\n        // Ensure user ID is available for refresh token operations\r\n        if (session.user && token.sub) {\r\n          session.user.id = token.sub;\r\n        }\r\n      }\r\n      return session;\r\n    },\r\n    async signIn({ user, account, profile, email, credentials }) {\r\n      // This callback is called when sign in succeeds\r\n      console.log(\"🔐 [AUTH CALLBACK] SignIn callback called with user:\", user);\r\n      return true; // Allow sign in\r\n    },\r\n  },\r\n  events: {\r\n    async signIn(message) {\r\n      console.log(\"🔐 [AUTH EVENT] Sign in event:\", message);\r\n    },\r\n    // async signOut(message) {\r\n    //   console.log(\"🔐 [AUTH EVENT] Sign out event\");\r\n      \r\n    //   try {\r\n    //     // Try to get token from session first, then from token\r\n    //     const accessToken = message.session?.accessToken || message.token?.accessToken;\r\n        \r\n    //     if (accessToken) {\r\n    //       OpenAPI.TOKEN = accessToken;\r\n    //       const response = await AuthService.petInsurancePlatformUsersEndpointsAuthLogoutEndpoint();\r\n    //       console.log(\"🔐 [AUTH EVENT] Backend logout successful\", response);\r\n    //     } else {\r\n    //       console.log(\"🔐 [AUTH EVENT] No access token found - skipping backend logout\");\r\n    //     }\r\n    //   } catch (error: any) {\r\n    //     console.error(\"🔐 [AUTH EVENT] Logout API error:\", error);\r\n    //     // Don't throw the error - logout should succeed even if API call fails\r\n    //     if (error?.status === 401) {\r\n    //       console.log(\"🔐 [AUTH EVENT] Token expired/invalid - continuing with logout\");\r\n    //     }\r\n    //   } finally {\r\n    //     // Always clear the token after logout attempt\r\n    //     OpenAPI.TOKEN = undefined;\r\n    //   }\r\n    // },\r\n  },\r\n  pages: {\r\n    signIn: \"/login\",\r\n  },\r\n  session: {\r\n    strategy: \"jwt\",\r\n    maxAge: 60 * 60, // 1 hour\r\n    updateAge: 24 * 60 * 60, // 24 hours\r\n  },\r\n  secret: process.env.NEXTAUTH_SECRET,\r\n}; "],"names":[],"mappings":";;;;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;;;;;;AAGO,MAAM,cAA2B;IACtC,WAAW;QACT,IAAA,iRAAmB,EAAC;YAClB,IAAI;YACJ,MAAM;YACN,aAAa;gBACX,aAAa;oBAAE,OAAO;oBAAgB,MAAM;gBAAO;gBACnD,KAAK;oBAAE,OAAO;oBAAO,MAAM;gBAAO;YAEpC;YACA,MAAM,WAAU,WAAW;gBACzB,IAAI,CAAC,aAAa,eAAe,CAAC,aAAa,KAAK;oBAClD,MAAM,IAAI,MAAM;gBAClB;gBAEA,IAAI;oBACF,MAAM,cAAc;wBAClB,aAAa,YAAY,WAAW;wBACpC,KAAK,YAAY,GAAG;oBACtB;oBAEA,gCAAgC;oBAChC,oCAAoC;oBACpC,2DAA2D;oBAC3D,IAAI;oBACJ,MAAM,QAAQ,8IAAO;oBACrB,MAAM,WAAW,MAAM,4LAA4B,CAAC,uBAAuB,CAAC;wBAC1E;oBACF;oBAEA,QAAQ,GAAG,CAAC,uBAAuB;oBAEnC,IAAI,UAAU,eAAe,UAAU,cAAc;wBACnD,8EAA8E;wBAC9E,IAAI;wBACJ,IAAI;4BACF,MAAM,eAAe,KAAK,KAAK,CAAC,KAAK,SAAS,WAAW,CAAC,KAAK,CAAC,IAAI,CAAC,EAAE;4BACvE,SAAS,aAAa,GAAG,IAAI,YAAY,WAAW;wBACtD,EAAE,OAAM;4BACN,SAAS,YAAY,WAAW;wBAClC;wBAEA,OAAO;4BACL,IAAI;4BACJ,aAAa,YAAY,WAAW;4BACpC,aAAa,SAAS,WAAW;4BACjC,cAAc,SAAS,YAAY;wBACrC;oBACF;oBACA,MAAM,IAAI,MAAM;gBAClB,EAAE,OAAO,OAAO;oBACd,QAAQ,KAAK,CAAC,oBAAoB;oBAClC,MAAM,eAAe,IAAA,oKAAyB,EAAC,OAAO;oBACtD,MAAM,IAAI,MAAM;gBAClB;YACF;QACF;KACD;IACD,WAAW;QACT,MAAM,KAAI,EAAE,KAAK,EAAE,IAAI,EAAE;YACvB,mFAAmF;YACnF,IAAI,MAAM;gBACR,MAAM,WAAW,GAAG,KAAK,WAAW;gBACpC,MAAM,YAAY,GAAG,KAAK,YAAY;gBACtC,MAAM,GAAG,GAAG,KAAK,EAAE,EAAE,yBAAyB;gBAC9C,MAAM,EAAE,GAAG,KAAK,EAAE;YACpB;YACA,OAAO;QACT;QACA,MAAM,SAAQ,EAAE,OAAO,EAAE,KAAK,EAAE;YAC9B,2DAA2D;YAC3D,IAAI,OAAO;gBACT,QAAQ,WAAW,GAAG,MAAM,WAAW;gBACvC,QAAQ,YAAY,GAAG,MAAM,YAAY;gBACzC,2DAA2D;gBAC3D,IAAI,QAAQ,IAAI,IAAI,MAAM,GAAG,EAAE;oBAC7B,QAAQ,IAAI,CAAC,EAAE,GAAG,MAAM,GAAG;gBAC7B;YACF;YACA,OAAO;QACT;QACA,MAAM,QAAO,EAAE,IAAI,EAAE,OAAO,EAAE,OAAO,EAAE,KAAK,EAAE,WAAW,EAAE;YACzD,gDAAgD;YAChD,QAAQ,GAAG,CAAC,wDAAwD;YACpE,OAAO,MAAM,gBAAgB;QAC/B;IACF;IACA,QAAQ;QACN,MAAM,QAAO,OAAO;YAClB,QAAQ,GAAG,CAAC,kCAAkC;QAChD;IA0BF;IACA,OAAO;QACL,QAAQ;IACV;IACA,SAAS;QACP,UAAU;QACV,QAAQ,KAAK;QACb,WAAW,KAAK,KAAK;IACvB;IACA,QAAQ,QAAQ,GAAG,CAAC,eAAe;AACrC","debugId":null}},
    {"offset": {"line": 913, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/matta/Desktop/Projects/saman-home-insurance/src/app/api/auth/%5B...nextauth%5D/route.ts"],"sourcesContent":["import { authOptions } from \"@/lib/auth\";\r\nimport NextAuth from \"next-auth\";\r\n\r\nconst handler = NextAuth(authOptions);\r\nexport { handler as GET, handler as POST };\r\n"],"names":[],"mappings":";;;;;;AAAA;AACA;;;AAEA,MAAM,UAAU,IAAA,8PAAQ,EAAC,mIAAW","debugId":null}}]
}