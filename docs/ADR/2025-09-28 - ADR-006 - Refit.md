# ADR-006: Adopt Refit for External API Communication

## Status
Decided

## Context
Our application needs to communicate with external APIs for various integrations including SMS providers, payment gateways, identity verification services, and third-party business services. We require a consistent, maintainable, and type-safe approach to HTTP client communication that reduces boilerplate code while providing excellent testability and error handling capabilities. The solution must integrate well with our existing architectural decisions including dependency injection, Result pattern usage, and clean architecture principles.

## Decision
We will adopt **Refit** as our HTTP client library for communicating with external APIs throughout the application.

## Rationale

**Type-Safe API Definitions**
- Interface-based API definitions provide compile-time safety for API contracts
- Automatic request/response serialization reduces manual JSON handling
- Strong typing prevents common errors in API endpoint URLs and parameters
- IntelliSense support improves developer productivity and reduces mistakes

**Reduced Boilerplate Code**
- Eliminates repetitive HttpClient configuration and manual HTTP request construction
- Automatic handling of query parameters, headers, and request bodies
- Built-in support for common HTTP patterns (GET, POST, PUT, DELETE, PATCH)
- Declarative API definitions are more readable and maintainable than imperative HttpClient code

**Integration with Modern .NET Practices**
- Native support for dependency injection and IHttpClientFactory
- Works seamlessly with ASP.NET Core middleware and delegating handlers
- Compatible with Polly for resilience policies (retry, circuit breaker, timeout)
- Supports modern async/await patterns throughout

**Excellent Testability**
- Interface-based design makes mocking external APIs straightforward
- Easy to create test doubles for integration testing
- Supports dependency injection making unit tests clean and isolated
- Can use tools like WireMock for contract testing

## Consequences

### Positive
- Significantly reduced boilerplate code for HTTP client implementations
- Type-safe API contracts with compile-time validation
- Excellent integration with dependency injection and IHttpClientFactory
- Easy to mock and test external API integrations
- Consistent pattern across all external API communications
- Built-in support for common HTTP scenarios and content types
- Better error handling through typed responses and Result pattern integration

### Negative
- Additional NuGet package dependency to manage
- Learning curve for developers unfamiliar with Refit
- Generated code can be harder to debug compared to explicit HttpClient calls
- Less flexibility for highly customized HTTP request scenarios
- Potential performance overhead from reflection-based implementation (minimal in practice)

### Implementation Notes
- Define Refit interfaces in Infrastructure layer within dedicated API client folders
- Register Refit clients using AddRefitClient extension method in Program.cs
- Combine with Polly policies for resilience (retry, circuit breaker, timeout)
- Use Result pattern wrappers for external API responses to maintain consistency
- Configure base URLs and API keys through IConfiguration
- Implement delegating handlers for cross-cutting concerns (authentication, logging, correlation IDs)
- Create wrapper services in Infrastructure layer that convert Refit responses to Result types
- Use IHttpClientFactory for proper HttpClient lifecycle management
- Establish naming conventions: I{ServiceName}ApiClient for Refit interfaces
- Configure reasonable timeouts and retry policies for each external service

## References
- Refit Official Documentation
- IHttpClientFactory Best Practices
- Polly Resilience Documentation
- Microsoft HTTP Client Guidelines